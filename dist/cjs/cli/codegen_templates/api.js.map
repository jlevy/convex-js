{
  "version": 3,
  "sources": ["../../../../src/cli/codegen_templates/api.ts"],
  "sourcesContent": ["import { header } from \"./common.js\";\nimport { extractComponentTypeAnnotation } from \"../lib/componentTypePreservation.js\";\n\nexport function importPath(modulePath: string) {\n  // Replace backslashes with forward slashes.\n  const filePath = modulePath.replace(/\\\\/g, \"/\");\n  // Strip off the file extension.\n  const lastDot = filePath.lastIndexOf(\".\");\n  return filePath.slice(0, lastDot === -1 ? undefined : lastDot);\n}\n\nexport function moduleIdentifier(modulePath: string) {\n  // TODO: This encoding is ambiguous (`foo/bar` vs `foo_bar` vs `foo-bar`).\n  // Also we should be renaming keywords like `delete`.\n  let safeModulePath = importPath(modulePath)\n    .replace(/\\//g, \"_\")\n    .replace(/-/g, \"_\");\n  // Escape existing variable names in this file\n  if ([\"fullApi\", \"api\", \"internal\", \"components\"].includes(safeModulePath)) {\n    safeModulePath = `${safeModulePath}_`;\n  }\n  // Escape reserved words which are legal property names unescaped but are not\n  // legal identifiers.\n  // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\n  const reserved = [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"class\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"else\",\n    \"export\",\n    \"extends\",\n    \"false\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"new\",\n    \"null\",\n    \"return\",\n    \"super\",\n    \"switch\",\n    \"this\",\n    \"throw\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"while\",\n    \"with\",\n    \"let\",\n    \"static\",\n    \"yield\",\n    \"await\",\n    \"enum\",\n    \"implements\",\n    \"interface\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n  ];\n  if (reserved.includes(safeModulePath)) {\n    safeModulePath = `${safeModulePath}_`;\n  }\n  return safeModulePath;\n}\n\nexport function apiCodegen(\n  modulePaths: string[],\n  opts?: {\n    useTypeScript?: boolean;\n    includeComponentsStub?: boolean;\n    preservedComponentTypes?: string | undefined;\n  },\n) {\n  const useTypeScript = opts?.useTypeScript ?? false;\n  const includeComponentsStub = opts?.includeComponentsStub ?? false;\n  const preservedComponentTypes = opts?.preservedComponentTypes;\n\n  if (!useTypeScript) {\n    // Generate separate .js and .d.ts files\n    // Use preserved component types if available, otherwise use stub if requested\n    let componentsImport = \"\";\n    let componentsExportDTS = \"\";\n    let componentsExportJS = \"\";\n\n    if (preservedComponentTypes) {\n      // Use preserved real component types (no need for AnyComponents import)\n      componentsExportDTS = `\\n${preservedComponentTypes}`;\n      // For JS runtime, still use componentsGeneric()\n      componentsExportJS = `\\nimport { componentsGeneric } from \"convex/server\";\\nexport const components = componentsGeneric();`;\n    } else if (includeComponentsStub) {\n      // Fall back to AnyComponents stub\n      componentsImport = \", AnyComponents\";\n      componentsExportDTS = \"\\nexport declare const components: AnyComponents;\";\n      componentsExportJS = `\\nimport { componentsGeneric } from \"convex/server\";\\nexport const components = componentsGeneric();`;\n    }\n\n    const apiDTS = `${header(\"Generated `api` utility.\")}\n  import type { ApiFromModules, FilterApi, FunctionReference${componentsImport} } from \"convex/server\";\n  ${modulePaths\n    .map(\n      (modulePath) =>\n        `import type * as ${moduleIdentifier(modulePath)} from \"../${importPath(\n          modulePath,\n        )}.js\";`,\n    )\n    .join(\"\\n\")}\n\n  /**\n   * A utility for referencing Convex functions in your app's API.\n   *\n   * Usage:\n   * \\`\\`\\`js\n   * const myFunctionReference = api.myModule.myFunction;\n   * \\`\\`\\`\n   */\n  declare const fullApi: ApiFromModules<{\n    ${modulePaths\n      .map(\n        (modulePath) =>\n          `\"${importPath(modulePath)}\": typeof ${moduleIdentifier(modulePath)},`,\n      )\n      .join(\"\\n\")}\n  }>;\n  export declare const api: FilterApi<typeof fullApi, FunctionReference<any, \"public\">>;\n  export declare const internal: FilterApi<typeof fullApi, FunctionReference<any, \"internal\">>;${componentsExportDTS}\n  `;\n\n    const apiJS = `${header(\"Generated `api` utility.\")}\n  import { anyApi } from \"convex/server\";\n\n  /**\n   * A utility for referencing Convex functions in your app's API.\n   *\n   * Usage:\n   * \\`\\`\\`js\n   * const myFunctionReference = api.myModule.myFunction;\n   * \\`\\`\\`\n   */\n  export const api = anyApi;\n  export const internal = anyApi;${componentsExportJS}\n  `;\n    return {\n      DTS: apiDTS,\n      JS: apiJS,\n    };\n  } else {\n    // Generate combined .ts file\n    // Use preserved component types if available, otherwise use stub if requested\n    let componentsImportTS = \"\";\n    let componentsImportRuntimeTS = \"\";\n    let componentsExportTS = \"\";\n\n    if (preservedComponentTypes) {\n      // For preserved types, we need componentsGeneric for runtime but use preserved type\n      componentsImportRuntimeTS = \", componentsGeneric\";\n      // Extract just the type annotation using TypeScript AST\n      const typeAnnotation = extractComponentTypeAnnotation(\n        preservedComponentTypes,\n      );\n      if (typeAnnotation) {\n        componentsExportTS = `\\n\\nexport const components: ${typeAnnotation} = componentsGeneric() as any;`;\n      } else {\n        // Fallback: use as-is (shouldn't happen with well-formed input)\n        componentsExportTS = `\\n\\n${preservedComponentTypes.replace(\"declare \", \"\")}`;\n      }\n    } else if (includeComponentsStub) {\n      // Fall back to AnyComponents stub\n      componentsImportTS = \", AnyComponents\";\n      componentsImportRuntimeTS = \", componentsGeneric\";\n      componentsExportTS = `\\n\\nexport const components: AnyComponents = componentsGeneric();`;\n    }\n\n    const apiTS = `${header(\"Generated `api` utility.\")}\nimport type { ApiFromModules, FilterApi, FunctionReference${componentsImportTS} } from \"convex/server\";\nimport { anyApi${componentsImportRuntimeTS} } from \"convex/server\";\n${modulePaths\n  .map(\n    (modulePath) =>\n      `import type * as ${moduleIdentifier(modulePath)} from \"../${importPath(\n        modulePath,\n      )}.js\";`,\n  )\n  .join(\"\\n\")}\n\nconst fullApi: ApiFromModules<{\n  ${modulePaths\n    .map(\n      (modulePath) =>\n        `\"${importPath(modulePath)}\": typeof ${moduleIdentifier(modulePath)},`,\n    )\n    .join(\"\\n\")}\n}> = anyApi as any;\n\n/**\n * A utility for referencing Convex functions in your app's public API.\n *\n * Usage:\n * \\`\\`\\`js\n * const myFunctionReference = api.myModule.myFunction;\n * \\`\\`\\`\n */\nexport const api: FilterApi<typeof fullApi, FunctionReference<any, \"public\">> = anyApi as any;\n\n/**\n * A utility for referencing Convex functions in your app's internal API.\n *\n * Usage:\n * \\`\\`\\`js\n * const myFunctionReference = internal.myModule.myFunction;\n * \\`\\`\\`\n */\nexport const internal: FilterApi<typeof fullApi, FunctionReference<any, \"internal\">> = anyApi as any;${componentsExportTS}\n`;\n    return {\n      TS: apiTS,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
